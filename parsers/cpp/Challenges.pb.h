// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Challenges.proto

#ifndef PROTOBUF_Challenges_2eproto__INCLUDED
#define PROTOBUF_Challenges_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Lol.pb.h"
#include "RLWE.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Challenges_2eproto();
void protobuf_AssignDesc_Challenges_2eproto();
void protobuf_ShutdownFile_Challenges_2eproto();

class ContParams;
class DiscParams;
class RLWRParams;
class Challenge;
class InstanceCont1;
class InstanceDisc1;
class InstanceRLWR1;
class InstanceCont;
class InstanceDisc;
class InstanceRLWR;
class Secret1;
class Secret;

// ===================================================================

class ContParams : public ::google::protobuf::Message {
 public:
  ContParams();
  virtual ~ContParams();

  ContParams(const ContParams& from);

  inline ContParams& operator=(const ContParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContParams& default_instance();

  void Swap(ContParams* other);

  // implements Message ----------------------------------------------

  ContParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContParams& from);
  void MergeFrom(const ContParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline ::google::protobuf::int32 m() const;
  inline void set_m(::google::protobuf::int32 value);

  // required int64 q = 2;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 2;
  inline ::google::protobuf::int64 q() const;
  inline void set_q(::google::protobuf::int64 value);

  // required double svar = 3;
  inline bool has_svar() const;
  inline void clear_svar();
  static const int kSvarFieldNumber = 3;
  inline double svar() const;
  inline void set_svar(double value);

  // required double bound = 4;
  inline bool has_bound() const;
  inline void clear_bound();
  static const int kBoundFieldNumber = 4;
  inline double bound() const;
  inline void set_bound(double value);

  // required int32 numSamples = 5;
  inline bool has_numsamples() const;
  inline void clear_numsamples();
  static const int kNumSamplesFieldNumber = 5;
  inline ::google::protobuf::int32 numsamples() const;
  inline void set_numsamples(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ContParams)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_svar();
  inline void clear_has_svar();
  inline void set_has_bound();
  inline void clear_has_bound();
  inline void set_has_numsamples();
  inline void clear_has_numsamples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 q_;
  double svar_;
  ::google::protobuf::int32 m_;
  ::google::protobuf::int32 numsamples_;
  double bound_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static ContParams* default_instance_;
};
// -------------------------------------------------------------------

class DiscParams : public ::google::protobuf::Message {
 public:
  DiscParams();
  virtual ~DiscParams();

  DiscParams(const DiscParams& from);

  inline DiscParams& operator=(const DiscParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscParams& default_instance();

  void Swap(DiscParams* other);

  // implements Message ----------------------------------------------

  DiscParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiscParams& from);
  void MergeFrom(const DiscParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline ::google::protobuf::int32 m() const;
  inline void set_m(::google::protobuf::int32 value);

  // required int64 q = 2;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 2;
  inline ::google::protobuf::int64 q() const;
  inline void set_q(::google::protobuf::int64 value);

  // required double svar = 3;
  inline bool has_svar() const;
  inline void clear_svar();
  static const int kSvarFieldNumber = 3;
  inline double svar() const;
  inline void set_svar(double value);

  // required int64 bound = 4;
  inline bool has_bound() const;
  inline void clear_bound();
  static const int kBoundFieldNumber = 4;
  inline ::google::protobuf::int64 bound() const;
  inline void set_bound(::google::protobuf::int64 value);

  // required int32 numSamples = 5;
  inline bool has_numsamples() const;
  inline void clear_numsamples();
  static const int kNumSamplesFieldNumber = 5;
  inline ::google::protobuf::int32 numsamples() const;
  inline void set_numsamples(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DiscParams)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_svar();
  inline void clear_has_svar();
  inline void set_has_bound();
  inline void clear_has_bound();
  inline void set_has_numsamples();
  inline void clear_has_numsamples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 q_;
  double svar_;
  ::google::protobuf::int32 m_;
  ::google::protobuf::int32 numsamples_;
  ::google::protobuf::int64 bound_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static DiscParams* default_instance_;
};
// -------------------------------------------------------------------

class RLWRParams : public ::google::protobuf::Message {
 public:
  RLWRParams();
  virtual ~RLWRParams();

  RLWRParams(const RLWRParams& from);

  inline RLWRParams& operator=(const RLWRParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RLWRParams& default_instance();

  void Swap(RLWRParams* other);

  // implements Message ----------------------------------------------

  RLWRParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RLWRParams& from);
  void MergeFrom(const RLWRParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m = 1;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 1;
  inline ::google::protobuf::int32 m() const;
  inline void set_m(::google::protobuf::int32 value);

  // required int64 q = 2;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 2;
  inline ::google::protobuf::int64 q() const;
  inline void set_q(::google::protobuf::int64 value);

  // required int64 p = 3;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 3;
  inline ::google::protobuf::int64 p() const;
  inline void set_p(::google::protobuf::int64 value);

  // required int32 numSamples = 4;
  inline bool has_numsamples() const;
  inline void clear_numsamples();
  static const int kNumSamplesFieldNumber = 4;
  inline ::google::protobuf::int32 numsamples() const;
  inline void set_numsamples(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RLWRParams)
 private:
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_numsamples();
  inline void clear_has_numsamples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 q_;
  ::google::protobuf::int32 m_;
  ::google::protobuf::int32 numsamples_;
  ::google::protobuf::int64 p_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static RLWRParams* default_instance_;
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  enum ParamsCase {
    kCparams = 5,
    kDparams = 6,
    kRparams = 7,
    PARAMS_NOT_SET = 0,
  };

  void Swap(Challenge* other);

  // implements Message ----------------------------------------------

  Challenge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 numInstances = 2;
  inline bool has_numinstances() const;
  inline void clear_numinstances();
  static const int kNumInstancesFieldNumber = 2;
  inline ::google::protobuf::int32 numinstances() const;
  inline void set_numinstances(::google::protobuf::int32 value);

  // required int64 beaconEpoch = 3;
  inline bool has_beaconepoch() const;
  inline void clear_beaconepoch();
  static const int kBeaconEpochFieldNumber = 3;
  inline ::google::protobuf::int64 beaconepoch() const;
  inline void set_beaconepoch(::google::protobuf::int64 value);

  // required int32 beaconOffset = 4;
  inline bool has_beaconoffset() const;
  inline void clear_beaconoffset();
  static const int kBeaconOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 beaconoffset() const;
  inline void set_beaconoffset(::google::protobuf::int32 value);

  // optional .ContParams cparams = 5;
  inline bool has_cparams() const;
  inline void clear_cparams();
  static const int kCparamsFieldNumber = 5;
  inline const ::ContParams& cparams() const;
  inline ::ContParams* mutable_cparams();
  inline ::ContParams* release_cparams();
  inline void set_allocated_cparams(::ContParams* cparams);

  // optional .DiscParams dparams = 6;
  inline bool has_dparams() const;
  inline void clear_dparams();
  static const int kDparamsFieldNumber = 6;
  inline const ::DiscParams& dparams() const;
  inline ::DiscParams* mutable_dparams();
  inline ::DiscParams* release_dparams();
  inline void set_allocated_dparams(::DiscParams* dparams);

  // optional .RLWRParams rparams = 7;
  inline bool has_rparams() const;
  inline void clear_rparams();
  static const int kRparamsFieldNumber = 7;
  inline const ::RLWRParams& rparams() const;
  inline ::RLWRParams* mutable_rparams();
  inline ::RLWRParams* release_rparams();
  inline void set_allocated_rparams(::RLWRParams* rparams);

  inline ParamsCase params_case() const;
  // @@protoc_insertion_point(class_scope:Challenge)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_numinstances();
  inline void clear_has_numinstances();
  inline void set_has_beaconepoch();
  inline void clear_has_beaconepoch();
  inline void set_has_beaconoffset();
  inline void clear_has_beaconoffset();
  inline void set_has_cparams();
  inline void set_has_dparams();
  inline void set_has_rparams();

  inline bool has_params();
  void clear_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 numinstances_;
  ::google::protobuf::int64 beaconepoch_;
  ::google::protobuf::int32 beaconoffset_;
  union ParamsUnion {
    ::ContParams* cparams_;
    ::DiscParams* dparams_;
    ::RLWRParams* rparams_;
  } params_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static Challenge* default_instance_;
};
// -------------------------------------------------------------------

class InstanceCont1 : public ::google::protobuf::Message {
 public:
  InstanceCont1();
  virtual ~InstanceCont1();

  InstanceCont1(const InstanceCont1& from);

  inline InstanceCont1& operator=(const InstanceCont1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceCont1& default_instance();

  void Swap(InstanceCont1* other);

  // implements Message ----------------------------------------------

  InstanceCont1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceCont1& from);
  void MergeFrom(const InstanceCont1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .ContParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::ContParams& params() const;
  inline ::ContParams* mutable_params();
  inline ::ContParams* release_params();
  inline void set_allocated_params(::ContParams* params);

  // repeated .SampleCont1 samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleCont1& samples(int index) const;
  inline ::SampleCont1* mutable_samples(int index);
  inline ::SampleCont1* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleCont1 >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleCont1 >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceCont1)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::ContParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleCont1 > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceCont1* default_instance_;
};
// -------------------------------------------------------------------

class InstanceDisc1 : public ::google::protobuf::Message {
 public:
  InstanceDisc1();
  virtual ~InstanceDisc1();

  InstanceDisc1(const InstanceDisc1& from);

  inline InstanceDisc1& operator=(const InstanceDisc1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceDisc1& default_instance();

  void Swap(InstanceDisc1* other);

  // implements Message ----------------------------------------------

  InstanceDisc1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceDisc1& from);
  void MergeFrom(const InstanceDisc1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .DiscParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::DiscParams& params() const;
  inline ::DiscParams* mutable_params();
  inline ::DiscParams* release_params();
  inline void set_allocated_params(::DiscParams* params);

  // repeated .SampleDisc1 samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleDisc1& samples(int index) const;
  inline ::SampleDisc1* mutable_samples(int index);
  inline ::SampleDisc1* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleDisc1 >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleDisc1 >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceDisc1)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::DiscParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleDisc1 > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceDisc1* default_instance_;
};
// -------------------------------------------------------------------

class InstanceRLWR1 : public ::google::protobuf::Message {
 public:
  InstanceRLWR1();
  virtual ~InstanceRLWR1();

  InstanceRLWR1(const InstanceRLWR1& from);

  inline InstanceRLWR1& operator=(const InstanceRLWR1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceRLWR1& default_instance();

  void Swap(InstanceRLWR1* other);

  // implements Message ----------------------------------------------

  InstanceRLWR1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceRLWR1& from);
  void MergeFrom(const InstanceRLWR1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .RLWRParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::RLWRParams& params() const;
  inline ::RLWRParams* mutable_params();
  inline ::RLWRParams* release_params();
  inline void set_allocated_params(::RLWRParams* params);

  // repeated .SampleRLWR1 samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleRLWR1& samples(int index) const;
  inline ::SampleRLWR1* mutable_samples(int index);
  inline ::SampleRLWR1* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleRLWR1 >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleRLWR1 >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceRLWR1)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::RLWRParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleRLWR1 > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceRLWR1* default_instance_;
};
// -------------------------------------------------------------------

class InstanceCont : public ::google::protobuf::Message {
 public:
  InstanceCont();
  virtual ~InstanceCont();

  InstanceCont(const InstanceCont& from);

  inline InstanceCont& operator=(const InstanceCont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceCont& default_instance();

  void Swap(InstanceCont* other);

  // implements Message ----------------------------------------------

  InstanceCont* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceCont& from);
  void MergeFrom(const InstanceCont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .ContParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::ContParams& params() const;
  inline ::ContParams* mutable_params();
  inline ::ContParams* release_params();
  inline void set_allocated_params(::ContParams* params);

  // repeated .SampleCont samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleCont& samples(int index) const;
  inline ::SampleCont* mutable_samples(int index);
  inline ::SampleCont* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleCont >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleCont >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceCont)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::ContParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleCont > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceCont* default_instance_;
};
// -------------------------------------------------------------------

class InstanceDisc : public ::google::protobuf::Message {
 public:
  InstanceDisc();
  virtual ~InstanceDisc();

  InstanceDisc(const InstanceDisc& from);

  inline InstanceDisc& operator=(const InstanceDisc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceDisc& default_instance();

  void Swap(InstanceDisc* other);

  // implements Message ----------------------------------------------

  InstanceDisc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceDisc& from);
  void MergeFrom(const InstanceDisc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .DiscParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::DiscParams& params() const;
  inline ::DiscParams* mutable_params();
  inline ::DiscParams* release_params();
  inline void set_allocated_params(::DiscParams* params);

  // repeated .SampleDisc samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleDisc& samples(int index) const;
  inline ::SampleDisc* mutable_samples(int index);
  inline ::SampleDisc* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleDisc >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleDisc >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceDisc)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::DiscParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleDisc > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceDisc* default_instance_;
};
// -------------------------------------------------------------------

class InstanceRLWR : public ::google::protobuf::Message {
 public:
  InstanceRLWR();
  virtual ~InstanceRLWR();

  InstanceRLWR(const InstanceRLWR& from);

  inline InstanceRLWR& operator=(const InstanceRLWR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceRLWR& default_instance();

  void Swap(InstanceRLWR* other);

  // implements Message ----------------------------------------------

  InstanceRLWR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceRLWR& from);
  void MergeFrom(const InstanceRLWR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required .RLWRParams params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::RLWRParams& params() const;
  inline ::RLWRParams* mutable_params();
  inline ::RLWRParams* release_params();
  inline void set_allocated_params(::RLWRParams* params);

  // repeated .SampleRLWR samples = 4;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 4;
  inline const ::SampleRLWR& samples(int index) const;
  inline ::SampleRLWR* mutable_samples(int index);
  inline ::SampleRLWR* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::SampleRLWR >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::SampleRLWR >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:InstanceRLWR)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::RLWRParams* params_;
  ::google::protobuf::RepeatedPtrField< ::SampleRLWR > samples_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static InstanceRLWR* default_instance_;
};
// -------------------------------------------------------------------

class Secret1 : public ::google::protobuf::Message {
 public:
  Secret1();
  virtual ~Secret1();

  Secret1(const Secret1& from);

  inline Secret1& operator=(const Secret1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret1& default_instance();

  void Swap(Secret1* other);

  // implements Message ----------------------------------------------

  Secret1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret1& from);
  void MergeFrom(const Secret1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required int32 m = 3;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 3;
  inline ::google::protobuf::int32 m() const;
  inline void set_m(::google::protobuf::int32 value);

  // required int64 q = 4;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 4;
  inline ::google::protobuf::int64 q() const;
  inline void set_q(::google::protobuf::int64 value);

  // required bytes seed = 5;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 5;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // required .Rq1 s = 6;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 6;
  inline const ::Rq1& s() const;
  inline ::Rq1* mutable_s();
  inline ::Rq1* release_s();
  inline void set_allocated_s(::Rq1* s);

  // @@protoc_insertion_point(class_scope:Secret1)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::google::protobuf::int64 q_;
  ::std::string* seed_;
  ::Rq1* s_;
  ::google::protobuf::int32 m_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static Secret1* default_instance_;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  void Swap(Secret* other);

  // implements Message ----------------------------------------------

  Secret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 challengeID = 1;
  inline bool has_challengeid() const;
  inline void clear_challengeid();
  static const int kChallengeIDFieldNumber = 1;
  inline ::google::protobuf::int32 challengeid() const;
  inline void set_challengeid(::google::protobuf::int32 value);

  // required int32 instanceID = 2;
  inline bool has_instanceid() const;
  inline void clear_instanceid();
  static const int kInstanceIDFieldNumber = 2;
  inline ::google::protobuf::int32 instanceid() const;
  inline void set_instanceid(::google::protobuf::int32 value);

  // required int32 m = 3;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 3;
  inline ::google::protobuf::int32 m() const;
  inline void set_m(::google::protobuf::int32 value);

  // required int64 q = 4;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 4;
  inline ::google::protobuf::int64 q() const;
  inline void set_q(::google::protobuf::int64 value);

  // required bytes seed = 5;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 5;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // required .RqProduct s = 6;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 6;
  inline const ::RqProduct& s() const;
  inline ::RqProduct* mutable_s();
  inline ::RqProduct* release_s();
  inline void set_allocated_s(::RqProduct* s);

  // @@protoc_insertion_point(class_scope:Secret)
 private:
  inline void set_has_challengeid();
  inline void clear_has_challengeid();
  inline void set_has_instanceid();
  inline void clear_has_instanceid();
  inline void set_has_m();
  inline void clear_has_m();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 challengeid_;
  ::google::protobuf::int32 instanceid_;
  ::google::protobuf::int64 q_;
  ::std::string* seed_;
  ::RqProduct* s_;
  ::google::protobuf::int32 m_;
  friend void  protobuf_AddDesc_Challenges_2eproto();
  friend void protobuf_AssignDesc_Challenges_2eproto();
  friend void protobuf_ShutdownFile_Challenges_2eproto();

  void InitAsDefaultInstance();
  static Secret* default_instance_;
};
// ===================================================================


// ===================================================================

// ContParams

// required int32 m = 1;
inline bool ContParams::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContParams::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContParams::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContParams::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline ::google::protobuf::int32 ContParams::m() const {
  // @@protoc_insertion_point(field_get:ContParams.m)
  return m_;
}
inline void ContParams::set_m(::google::protobuf::int32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:ContParams.m)
}

// required int64 q = 2;
inline bool ContParams::has_q() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContParams::set_has_q() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContParams::clear_has_q() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContParams::clear_q() {
  q_ = GOOGLE_LONGLONG(0);
  clear_has_q();
}
inline ::google::protobuf::int64 ContParams::q() const {
  // @@protoc_insertion_point(field_get:ContParams.q)
  return q_;
}
inline void ContParams::set_q(::google::protobuf::int64 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:ContParams.q)
}

// required double svar = 3;
inline bool ContParams::has_svar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContParams::set_has_svar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContParams::clear_has_svar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContParams::clear_svar() {
  svar_ = 0;
  clear_has_svar();
}
inline double ContParams::svar() const {
  // @@protoc_insertion_point(field_get:ContParams.svar)
  return svar_;
}
inline void ContParams::set_svar(double value) {
  set_has_svar();
  svar_ = value;
  // @@protoc_insertion_point(field_set:ContParams.svar)
}

// required double bound = 4;
inline bool ContParams::has_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContParams::set_has_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContParams::clear_has_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContParams::clear_bound() {
  bound_ = 0;
  clear_has_bound();
}
inline double ContParams::bound() const {
  // @@protoc_insertion_point(field_get:ContParams.bound)
  return bound_;
}
inline void ContParams::set_bound(double value) {
  set_has_bound();
  bound_ = value;
  // @@protoc_insertion_point(field_set:ContParams.bound)
}

// required int32 numSamples = 5;
inline bool ContParams::has_numsamples() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContParams::set_has_numsamples() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContParams::clear_has_numsamples() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContParams::clear_numsamples() {
  numsamples_ = 0;
  clear_has_numsamples();
}
inline ::google::protobuf::int32 ContParams::numsamples() const {
  // @@protoc_insertion_point(field_get:ContParams.numSamples)
  return numsamples_;
}
inline void ContParams::set_numsamples(::google::protobuf::int32 value) {
  set_has_numsamples();
  numsamples_ = value;
  // @@protoc_insertion_point(field_set:ContParams.numSamples)
}

// -------------------------------------------------------------------

// DiscParams

// required int32 m = 1;
inline bool DiscParams::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscParams::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscParams::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscParams::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline ::google::protobuf::int32 DiscParams::m() const {
  // @@protoc_insertion_point(field_get:DiscParams.m)
  return m_;
}
inline void DiscParams::set_m(::google::protobuf::int32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:DiscParams.m)
}

// required int64 q = 2;
inline bool DiscParams::has_q() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscParams::set_has_q() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscParams::clear_has_q() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscParams::clear_q() {
  q_ = GOOGLE_LONGLONG(0);
  clear_has_q();
}
inline ::google::protobuf::int64 DiscParams::q() const {
  // @@protoc_insertion_point(field_get:DiscParams.q)
  return q_;
}
inline void DiscParams::set_q(::google::protobuf::int64 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:DiscParams.q)
}

// required double svar = 3;
inline bool DiscParams::has_svar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscParams::set_has_svar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscParams::clear_has_svar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscParams::clear_svar() {
  svar_ = 0;
  clear_has_svar();
}
inline double DiscParams::svar() const {
  // @@protoc_insertion_point(field_get:DiscParams.svar)
  return svar_;
}
inline void DiscParams::set_svar(double value) {
  set_has_svar();
  svar_ = value;
  // @@protoc_insertion_point(field_set:DiscParams.svar)
}

// required int64 bound = 4;
inline bool DiscParams::has_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscParams::set_has_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscParams::clear_has_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscParams::clear_bound() {
  bound_ = GOOGLE_LONGLONG(0);
  clear_has_bound();
}
inline ::google::protobuf::int64 DiscParams::bound() const {
  // @@protoc_insertion_point(field_get:DiscParams.bound)
  return bound_;
}
inline void DiscParams::set_bound(::google::protobuf::int64 value) {
  set_has_bound();
  bound_ = value;
  // @@protoc_insertion_point(field_set:DiscParams.bound)
}

// required int32 numSamples = 5;
inline bool DiscParams::has_numsamples() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscParams::set_has_numsamples() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscParams::clear_has_numsamples() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscParams::clear_numsamples() {
  numsamples_ = 0;
  clear_has_numsamples();
}
inline ::google::protobuf::int32 DiscParams::numsamples() const {
  // @@protoc_insertion_point(field_get:DiscParams.numSamples)
  return numsamples_;
}
inline void DiscParams::set_numsamples(::google::protobuf::int32 value) {
  set_has_numsamples();
  numsamples_ = value;
  // @@protoc_insertion_point(field_set:DiscParams.numSamples)
}

// -------------------------------------------------------------------

// RLWRParams

// required int32 m = 1;
inline bool RLWRParams::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RLWRParams::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RLWRParams::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RLWRParams::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline ::google::protobuf::int32 RLWRParams::m() const {
  // @@protoc_insertion_point(field_get:RLWRParams.m)
  return m_;
}
inline void RLWRParams::set_m(::google::protobuf::int32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:RLWRParams.m)
}

// required int64 q = 2;
inline bool RLWRParams::has_q() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RLWRParams::set_has_q() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RLWRParams::clear_has_q() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RLWRParams::clear_q() {
  q_ = GOOGLE_LONGLONG(0);
  clear_has_q();
}
inline ::google::protobuf::int64 RLWRParams::q() const {
  // @@protoc_insertion_point(field_get:RLWRParams.q)
  return q_;
}
inline void RLWRParams::set_q(::google::protobuf::int64 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:RLWRParams.q)
}

// required int64 p = 3;
inline bool RLWRParams::has_p() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RLWRParams::set_has_p() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RLWRParams::clear_has_p() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RLWRParams::clear_p() {
  p_ = GOOGLE_LONGLONG(0);
  clear_has_p();
}
inline ::google::protobuf::int64 RLWRParams::p() const {
  // @@protoc_insertion_point(field_get:RLWRParams.p)
  return p_;
}
inline void RLWRParams::set_p(::google::protobuf::int64 value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:RLWRParams.p)
}

// required int32 numSamples = 4;
inline bool RLWRParams::has_numsamples() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RLWRParams::set_has_numsamples() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RLWRParams::clear_has_numsamples() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RLWRParams::clear_numsamples() {
  numsamples_ = 0;
  clear_has_numsamples();
}
inline ::google::protobuf::int32 RLWRParams::numsamples() const {
  // @@protoc_insertion_point(field_get:RLWRParams.numSamples)
  return numsamples_;
}
inline void RLWRParams::set_numsamples(::google::protobuf::int32 value) {
  set_has_numsamples();
  numsamples_ = value;
  // @@protoc_insertion_point(field_set:RLWRParams.numSamples)
}

// -------------------------------------------------------------------

// Challenge

// required int32 challengeID = 1;
inline bool Challenge::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Challenge::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Challenge::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Challenge::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 Challenge::challengeid() const {
  // @@protoc_insertion_point(field_get:Challenge.challengeID)
  return challengeid_;
}
inline void Challenge::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:Challenge.challengeID)
}

// required int32 numInstances = 2;
inline bool Challenge::has_numinstances() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Challenge::set_has_numinstances() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Challenge::clear_has_numinstances() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Challenge::clear_numinstances() {
  numinstances_ = 0;
  clear_has_numinstances();
}
inline ::google::protobuf::int32 Challenge::numinstances() const {
  // @@protoc_insertion_point(field_get:Challenge.numInstances)
  return numinstances_;
}
inline void Challenge::set_numinstances(::google::protobuf::int32 value) {
  set_has_numinstances();
  numinstances_ = value;
  // @@protoc_insertion_point(field_set:Challenge.numInstances)
}

// required int64 beaconEpoch = 3;
inline bool Challenge::has_beaconepoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Challenge::set_has_beaconepoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Challenge::clear_has_beaconepoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Challenge::clear_beaconepoch() {
  beaconepoch_ = GOOGLE_LONGLONG(0);
  clear_has_beaconepoch();
}
inline ::google::protobuf::int64 Challenge::beaconepoch() const {
  // @@protoc_insertion_point(field_get:Challenge.beaconEpoch)
  return beaconepoch_;
}
inline void Challenge::set_beaconepoch(::google::protobuf::int64 value) {
  set_has_beaconepoch();
  beaconepoch_ = value;
  // @@protoc_insertion_point(field_set:Challenge.beaconEpoch)
}

// required int32 beaconOffset = 4;
inline bool Challenge::has_beaconoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Challenge::set_has_beaconoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Challenge::clear_has_beaconoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Challenge::clear_beaconoffset() {
  beaconoffset_ = 0;
  clear_has_beaconoffset();
}
inline ::google::protobuf::int32 Challenge::beaconoffset() const {
  // @@protoc_insertion_point(field_get:Challenge.beaconOffset)
  return beaconoffset_;
}
inline void Challenge::set_beaconoffset(::google::protobuf::int32 value) {
  set_has_beaconoffset();
  beaconoffset_ = value;
  // @@protoc_insertion_point(field_set:Challenge.beaconOffset)
}

// optional .ContParams cparams = 5;
inline bool Challenge::has_cparams() const {
  return params_case() == kCparams;
}
inline void Challenge::set_has_cparams() {
  _oneof_case_[0] = kCparams;
}
inline void Challenge::clear_cparams() {
  if (has_cparams()) {
    delete params_.cparams_;
    clear_has_params();
  }
}
inline const ::ContParams& Challenge::cparams() const {
  return has_cparams() ? *params_.cparams_
                      : ::ContParams::default_instance();
}
inline ::ContParams* Challenge::mutable_cparams() {
  if (!has_cparams()) {
    clear_params();
    set_has_cparams();
    params_.cparams_ = new ::ContParams;
  }
  return params_.cparams_;
}
inline ::ContParams* Challenge::release_cparams() {
  if (has_cparams()) {
    clear_has_params();
    ::ContParams* temp = params_.cparams_;
    params_.cparams_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Challenge::set_allocated_cparams(::ContParams* cparams) {
  clear_params();
  if (cparams) {
    set_has_cparams();
    params_.cparams_ = cparams;
  }
}

// optional .DiscParams dparams = 6;
inline bool Challenge::has_dparams() const {
  return params_case() == kDparams;
}
inline void Challenge::set_has_dparams() {
  _oneof_case_[0] = kDparams;
}
inline void Challenge::clear_dparams() {
  if (has_dparams()) {
    delete params_.dparams_;
    clear_has_params();
  }
}
inline const ::DiscParams& Challenge::dparams() const {
  return has_dparams() ? *params_.dparams_
                      : ::DiscParams::default_instance();
}
inline ::DiscParams* Challenge::mutable_dparams() {
  if (!has_dparams()) {
    clear_params();
    set_has_dparams();
    params_.dparams_ = new ::DiscParams;
  }
  return params_.dparams_;
}
inline ::DiscParams* Challenge::release_dparams() {
  if (has_dparams()) {
    clear_has_params();
    ::DiscParams* temp = params_.dparams_;
    params_.dparams_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Challenge::set_allocated_dparams(::DiscParams* dparams) {
  clear_params();
  if (dparams) {
    set_has_dparams();
    params_.dparams_ = dparams;
  }
}

// optional .RLWRParams rparams = 7;
inline bool Challenge::has_rparams() const {
  return params_case() == kRparams;
}
inline void Challenge::set_has_rparams() {
  _oneof_case_[0] = kRparams;
}
inline void Challenge::clear_rparams() {
  if (has_rparams()) {
    delete params_.rparams_;
    clear_has_params();
  }
}
inline const ::RLWRParams& Challenge::rparams() const {
  return has_rparams() ? *params_.rparams_
                      : ::RLWRParams::default_instance();
}
inline ::RLWRParams* Challenge::mutable_rparams() {
  if (!has_rparams()) {
    clear_params();
    set_has_rparams();
    params_.rparams_ = new ::RLWRParams;
  }
  return params_.rparams_;
}
inline ::RLWRParams* Challenge::release_rparams() {
  if (has_rparams()) {
    clear_has_params();
    ::RLWRParams* temp = params_.rparams_;
    params_.rparams_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Challenge::set_allocated_rparams(::RLWRParams* rparams) {
  clear_params();
  if (rparams) {
    set_has_rparams();
    params_.rparams_ = rparams;
  }
}

inline bool Challenge::has_params() {
  return params_case() != PARAMS_NOT_SET;
}
inline void Challenge::clear_has_params() {
  _oneof_case_[0] = PARAMS_NOT_SET;
}
inline Challenge::ParamsCase Challenge::params_case() const {
  return Challenge::ParamsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InstanceCont1

// required int32 challengeID = 1;
inline bool InstanceCont1::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceCont1::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceCont1::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceCont1::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceCont1::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceCont1.challengeID)
  return challengeid_;
}
inline void InstanceCont1::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceCont1.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceCont1::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceCont1::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceCont1::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceCont1::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceCont1::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceCont1.instanceID)
  return instanceid_;
}
inline void InstanceCont1::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceCont1.instanceID)
}

// required .ContParams params = 3;
inline bool InstanceCont1::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceCont1::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceCont1::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceCont1::clear_params() {
  if (params_ != NULL) params_->::ContParams::Clear();
  clear_has_params();
}
inline const ::ContParams& InstanceCont1::params() const {
  // @@protoc_insertion_point(field_get:InstanceCont1.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::ContParams* InstanceCont1::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::ContParams;
  // @@protoc_insertion_point(field_mutable:InstanceCont1.params)
  return params_;
}
inline ::ContParams* InstanceCont1::release_params() {
  clear_has_params();
  ::ContParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceCont1::set_allocated_params(::ContParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceCont1.params)
}

// repeated .SampleCont1 samples = 4;
inline int InstanceCont1::samples_size() const {
  return samples_.size();
}
inline void InstanceCont1::clear_samples() {
  samples_.Clear();
}
inline const ::SampleCont1& InstanceCont1::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceCont1.samples)
  return samples_.Get(index);
}
inline ::SampleCont1* InstanceCont1::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceCont1.samples)
  return samples_.Mutable(index);
}
inline ::SampleCont1* InstanceCont1::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceCont1.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleCont1 >&
InstanceCont1::samples() const {
  // @@protoc_insertion_point(field_list:InstanceCont1.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleCont1 >*
InstanceCont1::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceCont1.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InstanceDisc1

// required int32 challengeID = 1;
inline bool InstanceDisc1::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceDisc1::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceDisc1::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceDisc1::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceDisc1::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceDisc1.challengeID)
  return challengeid_;
}
inline void InstanceDisc1::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceDisc1.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceDisc1::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceDisc1::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceDisc1::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceDisc1::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceDisc1::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceDisc1.instanceID)
  return instanceid_;
}
inline void InstanceDisc1::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceDisc1.instanceID)
}

// required .DiscParams params = 3;
inline bool InstanceDisc1::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceDisc1::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceDisc1::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceDisc1::clear_params() {
  if (params_ != NULL) params_->::DiscParams::Clear();
  clear_has_params();
}
inline const ::DiscParams& InstanceDisc1::params() const {
  // @@protoc_insertion_point(field_get:InstanceDisc1.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::DiscParams* InstanceDisc1::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::DiscParams;
  // @@protoc_insertion_point(field_mutable:InstanceDisc1.params)
  return params_;
}
inline ::DiscParams* InstanceDisc1::release_params() {
  clear_has_params();
  ::DiscParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceDisc1::set_allocated_params(::DiscParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceDisc1.params)
}

// repeated .SampleDisc1 samples = 4;
inline int InstanceDisc1::samples_size() const {
  return samples_.size();
}
inline void InstanceDisc1::clear_samples() {
  samples_.Clear();
}
inline const ::SampleDisc1& InstanceDisc1::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceDisc1.samples)
  return samples_.Get(index);
}
inline ::SampleDisc1* InstanceDisc1::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceDisc1.samples)
  return samples_.Mutable(index);
}
inline ::SampleDisc1* InstanceDisc1::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceDisc1.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleDisc1 >&
InstanceDisc1::samples() const {
  // @@protoc_insertion_point(field_list:InstanceDisc1.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleDisc1 >*
InstanceDisc1::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceDisc1.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InstanceRLWR1

// required int32 challengeID = 1;
inline bool InstanceRLWR1::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceRLWR1::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceRLWR1::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceRLWR1::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceRLWR1::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR1.challengeID)
  return challengeid_;
}
inline void InstanceRLWR1::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceRLWR1.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceRLWR1::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceRLWR1::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceRLWR1::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceRLWR1::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceRLWR1::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR1.instanceID)
  return instanceid_;
}
inline void InstanceRLWR1::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceRLWR1.instanceID)
}

// required .RLWRParams params = 3;
inline bool InstanceRLWR1::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceRLWR1::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceRLWR1::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceRLWR1::clear_params() {
  if (params_ != NULL) params_->::RLWRParams::Clear();
  clear_has_params();
}
inline const ::RLWRParams& InstanceRLWR1::params() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR1.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::RLWRParams* InstanceRLWR1::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::RLWRParams;
  // @@protoc_insertion_point(field_mutable:InstanceRLWR1.params)
  return params_;
}
inline ::RLWRParams* InstanceRLWR1::release_params() {
  clear_has_params();
  ::RLWRParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceRLWR1::set_allocated_params(::RLWRParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceRLWR1.params)
}

// repeated .SampleRLWR1 samples = 4;
inline int InstanceRLWR1::samples_size() const {
  return samples_.size();
}
inline void InstanceRLWR1::clear_samples() {
  samples_.Clear();
}
inline const ::SampleRLWR1& InstanceRLWR1::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceRLWR1.samples)
  return samples_.Get(index);
}
inline ::SampleRLWR1* InstanceRLWR1::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceRLWR1.samples)
  return samples_.Mutable(index);
}
inline ::SampleRLWR1* InstanceRLWR1::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceRLWR1.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleRLWR1 >&
InstanceRLWR1::samples() const {
  // @@protoc_insertion_point(field_list:InstanceRLWR1.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleRLWR1 >*
InstanceRLWR1::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceRLWR1.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InstanceCont

// required int32 challengeID = 1;
inline bool InstanceCont::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceCont::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceCont::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceCont::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceCont::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceCont.challengeID)
  return challengeid_;
}
inline void InstanceCont::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceCont.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceCont::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceCont::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceCont::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceCont::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceCont::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceCont.instanceID)
  return instanceid_;
}
inline void InstanceCont::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceCont.instanceID)
}

// required .ContParams params = 3;
inline bool InstanceCont::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceCont::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceCont::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceCont::clear_params() {
  if (params_ != NULL) params_->::ContParams::Clear();
  clear_has_params();
}
inline const ::ContParams& InstanceCont::params() const {
  // @@protoc_insertion_point(field_get:InstanceCont.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::ContParams* InstanceCont::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::ContParams;
  // @@protoc_insertion_point(field_mutable:InstanceCont.params)
  return params_;
}
inline ::ContParams* InstanceCont::release_params() {
  clear_has_params();
  ::ContParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceCont::set_allocated_params(::ContParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceCont.params)
}

// repeated .SampleCont samples = 4;
inline int InstanceCont::samples_size() const {
  return samples_.size();
}
inline void InstanceCont::clear_samples() {
  samples_.Clear();
}
inline const ::SampleCont& InstanceCont::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceCont.samples)
  return samples_.Get(index);
}
inline ::SampleCont* InstanceCont::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceCont.samples)
  return samples_.Mutable(index);
}
inline ::SampleCont* InstanceCont::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceCont.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleCont >&
InstanceCont::samples() const {
  // @@protoc_insertion_point(field_list:InstanceCont.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleCont >*
InstanceCont::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceCont.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InstanceDisc

// required int32 challengeID = 1;
inline bool InstanceDisc::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceDisc::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceDisc::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceDisc::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceDisc::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceDisc.challengeID)
  return challengeid_;
}
inline void InstanceDisc::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceDisc.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceDisc::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceDisc::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceDisc::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceDisc::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceDisc::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceDisc.instanceID)
  return instanceid_;
}
inline void InstanceDisc::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceDisc.instanceID)
}

// required .DiscParams params = 3;
inline bool InstanceDisc::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceDisc::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceDisc::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceDisc::clear_params() {
  if (params_ != NULL) params_->::DiscParams::Clear();
  clear_has_params();
}
inline const ::DiscParams& InstanceDisc::params() const {
  // @@protoc_insertion_point(field_get:InstanceDisc.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::DiscParams* InstanceDisc::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::DiscParams;
  // @@protoc_insertion_point(field_mutable:InstanceDisc.params)
  return params_;
}
inline ::DiscParams* InstanceDisc::release_params() {
  clear_has_params();
  ::DiscParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceDisc::set_allocated_params(::DiscParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceDisc.params)
}

// repeated .SampleDisc samples = 4;
inline int InstanceDisc::samples_size() const {
  return samples_.size();
}
inline void InstanceDisc::clear_samples() {
  samples_.Clear();
}
inline const ::SampleDisc& InstanceDisc::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceDisc.samples)
  return samples_.Get(index);
}
inline ::SampleDisc* InstanceDisc::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceDisc.samples)
  return samples_.Mutable(index);
}
inline ::SampleDisc* InstanceDisc::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceDisc.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleDisc >&
InstanceDisc::samples() const {
  // @@protoc_insertion_point(field_list:InstanceDisc.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleDisc >*
InstanceDisc::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceDisc.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InstanceRLWR

// required int32 challengeID = 1;
inline bool InstanceRLWR::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceRLWR::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceRLWR::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceRLWR::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 InstanceRLWR::challengeid() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR.challengeID)
  return challengeid_;
}
inline void InstanceRLWR::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:InstanceRLWR.challengeID)
}

// required int32 instanceID = 2;
inline bool InstanceRLWR::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceRLWR::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceRLWR::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceRLWR::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 InstanceRLWR::instanceid() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR.instanceID)
  return instanceid_;
}
inline void InstanceRLWR::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:InstanceRLWR.instanceID)
}

// required .RLWRParams params = 3;
inline bool InstanceRLWR::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceRLWR::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceRLWR::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceRLWR::clear_params() {
  if (params_ != NULL) params_->::RLWRParams::Clear();
  clear_has_params();
}
inline const ::RLWRParams& InstanceRLWR::params() const {
  // @@protoc_insertion_point(field_get:InstanceRLWR.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::RLWRParams* InstanceRLWR::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::RLWRParams;
  // @@protoc_insertion_point(field_mutable:InstanceRLWR.params)
  return params_;
}
inline ::RLWRParams* InstanceRLWR::release_params() {
  clear_has_params();
  ::RLWRParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void InstanceRLWR::set_allocated_params(::RLWRParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:InstanceRLWR.params)
}

// repeated .SampleRLWR samples = 4;
inline int InstanceRLWR::samples_size() const {
  return samples_.size();
}
inline void InstanceRLWR::clear_samples() {
  samples_.Clear();
}
inline const ::SampleRLWR& InstanceRLWR::samples(int index) const {
  // @@protoc_insertion_point(field_get:InstanceRLWR.samples)
  return samples_.Get(index);
}
inline ::SampleRLWR* InstanceRLWR::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceRLWR.samples)
  return samples_.Mutable(index);
}
inline ::SampleRLWR* InstanceRLWR::add_samples() {
  // @@protoc_insertion_point(field_add:InstanceRLWR.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SampleRLWR >&
InstanceRLWR::samples() const {
  // @@protoc_insertion_point(field_list:InstanceRLWR.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::SampleRLWR >*
InstanceRLWR::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:InstanceRLWR.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// Secret1

// required int32 challengeID = 1;
inline bool Secret1::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret1::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret1::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret1::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 Secret1::challengeid() const {
  // @@protoc_insertion_point(field_get:Secret1.challengeID)
  return challengeid_;
}
inline void Secret1::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:Secret1.challengeID)
}

// required int32 instanceID = 2;
inline bool Secret1::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret1::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret1::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret1::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 Secret1::instanceid() const {
  // @@protoc_insertion_point(field_get:Secret1.instanceID)
  return instanceid_;
}
inline void Secret1::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:Secret1.instanceID)
}

// required int32 m = 3;
inline bool Secret1::has_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret1::set_has_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret1::clear_has_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret1::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline ::google::protobuf::int32 Secret1::m() const {
  // @@protoc_insertion_point(field_get:Secret1.m)
  return m_;
}
inline void Secret1::set_m(::google::protobuf::int32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:Secret1.m)
}

// required int64 q = 4;
inline bool Secret1::has_q() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Secret1::set_has_q() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Secret1::clear_has_q() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Secret1::clear_q() {
  q_ = GOOGLE_LONGLONG(0);
  clear_has_q();
}
inline ::google::protobuf::int64 Secret1::q() const {
  // @@protoc_insertion_point(field_get:Secret1.q)
  return q_;
}
inline void Secret1::set_q(::google::protobuf::int64 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:Secret1.q)
}

// required bytes seed = 5;
inline bool Secret1::has_seed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Secret1::set_has_seed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Secret1::clear_has_seed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Secret1::clear_seed() {
  if (seed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& Secret1::seed() const {
  // @@protoc_insertion_point(field_get:Secret1.seed)
  return *seed_;
}
inline void Secret1::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
  // @@protoc_insertion_point(field_set:Secret1.seed)
}
inline void Secret1::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
  // @@protoc_insertion_point(field_set_char:Secret1.seed)
}
inline void Secret1::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Secret1.seed)
}
inline ::std::string* Secret1::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Secret1.seed)
  return seed_;
}
inline ::std::string* Secret1::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret1::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Secret1.seed)
}

// required .Rq1 s = 6;
inline bool Secret1::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Secret1::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Secret1::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Secret1::clear_s() {
  if (s_ != NULL) s_->::Rq1::Clear();
  clear_has_s();
}
inline const ::Rq1& Secret1::s() const {
  // @@protoc_insertion_point(field_get:Secret1.s)
  return s_ != NULL ? *s_ : *default_instance_->s_;
}
inline ::Rq1* Secret1::mutable_s() {
  set_has_s();
  if (s_ == NULL) s_ = new ::Rq1;
  // @@protoc_insertion_point(field_mutable:Secret1.s)
  return s_;
}
inline ::Rq1* Secret1::release_s() {
  clear_has_s();
  ::Rq1* temp = s_;
  s_ = NULL;
  return temp;
}
inline void Secret1::set_allocated_s(::Rq1* s) {
  delete s_;
  s_ = s;
  if (s) {
    set_has_s();
  } else {
    clear_has_s();
  }
  // @@protoc_insertion_point(field_set_allocated:Secret1.s)
}

// -------------------------------------------------------------------

// Secret

// required int32 challengeID = 1;
inline bool Secret::has_challengeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_challengeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 Secret::challengeid() const {
  // @@protoc_insertion_point(field_get:Secret.challengeID)
  return challengeid_;
}
inline void Secret::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:Secret.challengeID)
}

// required int32 instanceID = 2;
inline bool Secret::has_instanceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_instanceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_instanceid() {
  instanceid_ = 0;
  clear_has_instanceid();
}
inline ::google::protobuf::int32 Secret::instanceid() const {
  // @@protoc_insertion_point(field_get:Secret.instanceID)
  return instanceid_;
}
inline void Secret::set_instanceid(::google::protobuf::int32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:Secret.instanceID)
}

// required int32 m = 3;
inline bool Secret::has_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret::set_has_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret::clear_has_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline ::google::protobuf::int32 Secret::m() const {
  // @@protoc_insertion_point(field_get:Secret.m)
  return m_;
}
inline void Secret::set_m(::google::protobuf::int32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:Secret.m)
}

// required int64 q = 4;
inline bool Secret::has_q() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Secret::set_has_q() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Secret::clear_has_q() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Secret::clear_q() {
  q_ = GOOGLE_LONGLONG(0);
  clear_has_q();
}
inline ::google::protobuf::int64 Secret::q() const {
  // @@protoc_insertion_point(field_get:Secret.q)
  return q_;
}
inline void Secret::set_q(::google::protobuf::int64 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:Secret.q)
}

// required bytes seed = 5;
inline bool Secret::has_seed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Secret::set_has_seed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Secret::clear_has_seed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Secret::clear_seed() {
  if (seed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& Secret::seed() const {
  // @@protoc_insertion_point(field_get:Secret.seed)
  return *seed_;
}
inline void Secret::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
  // @@protoc_insertion_point(field_set:Secret.seed)
}
inline void Secret::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
  // @@protoc_insertion_point(field_set_char:Secret.seed)
}
inline void Secret::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Secret.seed)
}
inline ::std::string* Secret::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seed_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Secret.seed)
  return seed_;
}
inline ::std::string* Secret::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Secret::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Secret.seed)
}

// required .RqProduct s = 6;
inline bool Secret::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Secret::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Secret::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Secret::clear_s() {
  if (s_ != NULL) s_->::RqProduct::Clear();
  clear_has_s();
}
inline const ::RqProduct& Secret::s() const {
  // @@protoc_insertion_point(field_get:Secret.s)
  return s_ != NULL ? *s_ : *default_instance_->s_;
}
inline ::RqProduct* Secret::mutable_s() {
  set_has_s();
  if (s_ == NULL) s_ = new ::RqProduct;
  // @@protoc_insertion_point(field_mutable:Secret.s)
  return s_;
}
inline ::RqProduct* Secret::release_s() {
  clear_has_s();
  ::RqProduct* temp = s_;
  s_ = NULL;
  return temp;
}
inline void Secret::set_allocated_s(::RqProduct* s) {
  delete s_;
  s_ = s;
  if (s) {
    set_has_s();
  } else {
    clear_has_s();
  }
  // @@protoc_insertion_point(field_set_allocated:Secret.s)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Challenges_2eproto__INCLUDED
