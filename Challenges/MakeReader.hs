{-# LANGUAGE FlexibleContexts, GADTs #-}

module Challenges.MakeReader (Challenge(..), mkReader, tryReadChallenge) where

import Challenges.LWE
import Challenges.Verify

import Control.Monad.Trans
import Control.Monad.Trans.Maybe

import Crypto.Lol.Types.Proto

import Data.ByteString as BS hiding (putStrLn, null, map, tail, init, writeFile, intercalate)
import Data.ByteString.Lazy (toStrict, fromStrict, null)
import Data.List hiding (null)
import Data.List.Split

import Prelude hiding (null)

import System.Directory

import Text.ProtocolBuffers.Header (ReflectDescriptor, Wire)

data Challenge where
  Challenge :: String -> LWEChallenge v t m zp -> Challenge

tryReadChallenge :: (a ~ LWEChallenge v t m zp, ReflectDescriptor (ProtoType a), 
                     Wire (ProtoType a), Protoable a) 
  => FilePath -> MaybeT IO (LWEChallenge v t m zp)
tryReadChallenge path = do
  let challengeFile = challengePath ++ "/" ++ path
  foundChallenge <- lift $ doesFileExist challengeFile
  if foundChallenge
  then msgGet' <$> (lift $ BS.readFile challengeFile)
  else do
    lift $ putStrLn $ "Could not find challenge " ++ challengeFile ++ ". Skipping..."
    MaybeT $ return Nothing

msgGet' :: (ReflectDescriptor (ProtoType a), Wire (ProtoType a), Protoable a) => ByteString -> a
msgGet' bs = 
  case msgGet $ fromStrict bs of
    (Left str) -> error $ "when getting protocol buffer. Got string " ++ str
    (Right (a,bs')) -> 
      if null bs'
      then a
      else error $ "when getting protocol buffer. There were leftover bits!"

data TensorType = RT | CT deriving (Show)

mkReader :: [String] -> IO ()
mkReader names =
  let header = 
       "{-# LANGUAGE DataKinds, ScopedTypeVariables, TemplateHaskell, TypeFamilies #-}\n\n" ++
       "--Don't modify this file: it is generated by `mkReader` in Challenges.MakeReader\n\n" ++
       "module Challenges.Reader where\n\n" ++
       "import Challenges.LWE\n" ++ 
       "import Challenges.MakeReader\n" ++ 
       "import Control.Applicative\n" ++ 
       "import Control.Monad.Trans.Maybe\n" ++ 
       "import Crypto.Lol (fType,Proxy)\n" ++
       "import Data.Maybe\n" ++ 
       "import Utils\n\n"
      body = 
       "readChallenges (_::Proxy t) = catMaybes <$> (sequence $ map runMaybeT [\n" ++
       (intercalate ",\n" $ map readChallenge names) ++ "])"
      readChallenge name = 
        let (m,q) = parseName name
        in "  Challenge \"" ++ name ++ "\" <$> (tryReadChallenge \"" ++ name ++ 
           "\" :: MaybeT IO (LWEChallenge Double t $(fType " ++ (showInt m) ++ ") (Zq " ++ (showInt q) ++ ")))"
      parseName str = 
        let [m,q] = init $ tail $ splitOn "-" str
        in (m,q)
      showInt = init . tail . show
  in writeFile "challenges/Challenges/Reader.hs" $ header ++ body
